<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker114 Crawler</title>
    <link rel="icon" type="image/x-icon" href="favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body{margin:0;padding:0;font-family:Arial,sans-serif;background:#000;color:#fff;overflow:hidden;height:100vh}
        .header{display:flex;justify-content:space-between;align-items:center;padding:0 20px;background:#111;border-bottom:3px solid #f00;position:relative;z-index:10}
        .made-by{position:absolute;right:20px;top:50%;transform:translateY(-50%);color:#f00;font-weight:bold;font-size:14px}
        .tabs{display:flex;background:#111}
        .tab{padding:16px 35px;cursor:pointer;background:#222;color:#fff;font-weight:bold;transition:.3s}
        .tab:hover{background:#f00}
        .tab.active{background:#f00;box-shadow:0 0 20px #f00}
        .content{display:none;height:calc(100vh - 56px)}
        .content.active{display:flex}
        #manual-editor{flex-direction:row}
        .editor-panel{width:50%;padding:20px;background:#111;overflow-y:auto;border-right:2px solid #f00;box-sizing:border-box}
        .preview-panel{width:50%;position:relative;background:#000}
        #preview-iframe{width:100%;height:100%;border:none;background:#fff}
        .file-section{margin-bottom:25px;background:#111;padding:18px;border-radius:12px;border:1px solid #f00;box-shadow:0 0 15px rgba(255,0,0,.3)}
        .file-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;gap:10px;flex-wrap:wrap}
        .file-name{padding:10px 15px;background:#222;border:1px solid #f00;color:#ff3333;border-radius:6px;font-weight:bold;flex:1;min-width:150px}
        .copy-btn,.download-btn{padding:10px 22px;background:#f00;border:none;color:#fff;font-weight:bold;border-radius:6px;cursor:pointer;transition:.3s;margin-left:8px}
        .copy-btn:hover{background:#ff3333}
        .download-btn{background:#0066ff}
        .download-btn:hover{background:#0055cc}
        .zip-btn,.single-btn{background:#0f0;color:#000;padding:12px 30px;font-weight:bold;border:none;border-radius:8px;cursor:pointer;margin:10px 8px;transition:.3s;display:inline-block}
        .zip-btn:hover{background:#0c0}
        .single-btn:hover{background:#0c0}
        .zip-btn:disabled,.single-btn:disabled{background:#333;cursor:not-allowed}
        .file-content{width:100%;height:260px;background:#000;border:1px solid #f00;color:#0f0;padding:12px;border-radius:8px;font-family:'Courier New',monospace;font-size:14px;resize:vertical}
        #add-file{padding:16px 35px;background:#f00;border:none;color:#fff;font-weight:bold;border-radius:8px;margin:20px 0;cursor:pointer;transition:.3s}
        #add-file:hover{background:#c00}
        #fullscreen-btn{position:absolute;top:12px;right:12px;padding:10px 20px;background:#f00;border:none;color:#fff;cursor:pointer;border-radius:6px;z-index:10;transition:.3s}
        #fullscreen-btn:hover{background:#c00}
        .fetch-header{padding:20px;background:#111;border-bottom:2px solid #f00;display:flex;flex-direction:column;align-items:center;gap:15px}
        #url-input{width:80%;max-width:600px;padding:16px;background:#222;border:2px solid #f00;color:#fff;border-radius:8px;font-size:17px;outline:none}
        #url-input:focus{border-color:#ff3333}
        #fetch-btn{padding:16px 40px;background:#f00;border:none;color:#fff;font-weight:bold;border-radius:8px;cursor:pointer;transition:.3s}
        #fetch-btn:hover{background:#c00}
        #fetched-files{flex:1;overflow-y:auto;padding:20px;background:#000}
        .status{padding:12px;background:#300;color:#f66;text-align:center;border-radius:8px;margin:10px 0;font-weight:bold}
        .error-status{background:#500;color:#fcc}
        .fullscreen .preview-panel{width:100vw;height:100vh;position:fixed;top:0;left:0;z-index:100;background:#000}
        .fullscreen .editor-panel,.fullscreen .header,.fullscreen .tabs{display:none}
    </style>
</head>
<body>
<div class="header">
    <div class="tabs">
        <div class="tab active" data-tab="manual">Manual Editor</div>
        <div class="tab" data-tab="fetch">Auto Crawler</div>
    </div>
    <div class="made-by">Made by Hacker114</div>
</div>
<div id="manual-editor" class="content active">
    <div class="editor-panel">
        <button id="add-file">+ Add File</button>
        <div id="files-container"></div>
    </div>
    <div class="preview-panel">
        <button id="fullscreen-btn">Fullscreen</button>
        <iframe id="preview-iframe" sandbox="allow-scripts allow-modals allow-popups"></iframe>
    </div>
</div>
<div id="fetch-page" class="content">
    <div class="fetch-header">
        <input type="text" id="url-input" placeholder="https://example.com or example.com/page.html">
        <button id="fetch-btn">Fetch Files</button>
        <div style="display:flex;gap:10px;margin-top:10px;">
            <button id="download-zip" class="zip-btn" style="display:none;">Download All as ZIP</button>
            <button id="download-single" class="single-btn" style="display:none;">Download All as Single HTML</button>
        </div>
        <div id="progress" class="status" style="display:none;"></div>
    </div>
    <div id="fetched-files">
        <div class="status">Enter a URL and click Fetch Files</div>
    </div>
</div>
<script>
// Universal download
function downloadFile(filename, content, type = 'text/plain') {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
// Tab switching
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab === 'manual' ? 'manual-editor' : 'fetch-page').classList.add('active');
    });
});
/* Manual Editor */
let files = [];
function addFile(name = 'index.html', content = '') {
    const index = files.length;
    if (!content) {
        content = `<!DOCTYPE html>
<html>
<head><title>${name}</title></head>
<body style="background:#000;color:#0f0;font-family:monospace;text-align:center;padding-top:100px">
    <h1 style="color:#f00">Live Preview Works!</h1>
    <p>Start editing on the left</p>
</body>
</html>`;
    }
    files.push({ name, content });
    const container = document.getElementById('files-container');
    const section = document.createElement('div');
    section.className = 'file-section';
    section.innerHTML = `
        <div class="file-header">
            <input type="text" class="file-name" value="${name}" data-index="${index}">
            <button class="copy-btn" data-index="${index}">Copy</button>
            <button class="download-btn" data-index="${index}">Download</button>
        </div>
        <textarea class="file-content" data-index="${index}">${content}</textarea>`;
    container.appendChild(section);
    updatePreview();
}
document.getElementById('files-container').addEventListener('input', e => {
    if (e.target.matches('.file-name')) files[+e.target.dataset.index].name = e.target.value;
    if (e.target.matches('.file-content')) files[+e.target.dataset.index].content = e.target.value;
    updatePreview();
});
document.getElementById('files-container').addEventListener('click', e => {
    if (e.target.matches('.copy-btn')) navigator.clipboard.writeText(files[+e.target.dataset.index].content);
    if (e.target.matches('.download-btn')) {
        const f = files[+e.target.dataset.index];
        const type = f.name.endsWith('.css') ? 'text/css' : f.name.endsWith('.js') ? 'application/javascript' : 'text/html';
        downloadFile(f.name, f.content, type);
    }
});
document.getElementById('add-file').addEventListener('click', () => addFile());
function updatePreview() {
    let html = '', css = [], js = [];
    files.forEach(f => {
        const n = f.name.toLowerCase();
        if (n.endsWith('.html')) html = f.content;
        else if (n.endsWith('.css')) css.push(f.content);
        else if (n.endsWith('.js')) js.push(f.content);
    });
    if (!html.trim()) html = `<h1 style="color:#f00;text-align:center;margin-top:100px">Add an HTML file to see preview</h1>`;
    css.forEach(c => html += `\n<style>${c}</style>`);
    js.forEach(j => html += `\n<script>${j}<\/script>`);
    document.getElementById('preview-iframe').srcdoc = html;
}
document.getElementById('fullscreen-btn').addEventListener('click', () => {
    document.body.classList.toggle('fullscreen');
    this.textContent = document.body.classList.contains('fullscreen') ? 'Exit Fullscreen' : 'Fullscreen';
});
/* Auto Scraper */
const PROXY = 'https://api.allorigins.win/raw?url=';
let fetchedFiles = [];
let globalVisitedUrls = new Set();
function resolve(base, url) {
    try { return new URL(url, base).href; } catch { return url; }
}
function getRelativePath(fromDir, toPath) {
    const fromParts = fromDir.split('/').filter(Boolean);
    const toParts = toPath.split('/').filter(Boolean);
    let i = 0;
    while (i < fromParts.length && i < toParts.length && fromParts[i] === toParts[i]) i++;
    return '../'.repeat(fromParts.length - i) + toParts.slice(i).join('/') || './';
}
async function processPage(url, rootUrl, progress) {
    if (globalVisitedUrls.has(url)) return [];
    globalVisitedUrls.add(url);
    progress.textContent = `Fetching page: ${url}`;
    progress.style.background = '#330';
    let html_text = '';
    try {
        const res = await fetch(PROXY + encodeURIComponent(url));
        if (!res.ok) throw new Error('Bad response');
        html_text = await res.text();
    } catch (e) {
        progress.textContent = 'Failed to fetch page';
        progress.style.background = '#500';
        progress.classList.add('error-status');
        return [];
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(html_text, 'text/html');
    const pageBase = url.substring(0, url.lastIndexOf('/') + 1);
    const htmlPath = url.substring(rootUrl.length) || 'index.html';
    const htmlDir = htmlPath.substring(0, htmlPath.lastIndexOf('/') + 1);
    const pageAssetMap = new Map();
    const internalLinks = new Set();
    doc.querySelectorAll('a[href]').forEach(el => {
        const href = el.getAttribute('href');
        if (href) {
            const full = resolve(pageBase, href);
            if (full.startsWith(rootUrl)) internalLinks.add(full);
        }
    });
    ['link[rel="stylesheet"]', 'script[src]', 'img[src]', 'link[rel="icon"]', 'link[rel="shortcut icon"]'].forEach(sel => {
        doc.querySelectorAll(sel).forEach(el => {
            const attr = el.hasAttribute('src') ? 'src' : 'href';
            const original = el.getAttribute(attr);
            if (!original || original.startsWith('data:')) return;
            const full = resolve(pageBase, original);
            if (globalVisitedUrls.has(full)) return;
            const localPath = full.startsWith(rootUrl) ? full.substring(rootUrl.length) : 'assets/' + full.split('/').pop().split('?')[0];
            pageAssetMap.set(full, localPath);
            const relative = getRelativePath(htmlDir, localPath);
            el.setAttribute(attr, relative);
        });
    });
    const modifiedHtml = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
    addFetchedFile(htmlPath, modifiedHtml, false);
    fetchedFiles.push({ name: htmlPath, content: modifiedHtml, type: 'text/html' });
    const assets = Array.from(pageAssetMap.entries());
    progress.textContent = `Fetching ${assets.length} assets... (0/${assets.length})`;
    let done = 0;
    await Promise.all(assets.map(async ([fullUrl, localName]) => {
        globalVisitedUrls.add(fullUrl);
        try {
            const res = await fetch(PROXY + encodeURIComponent(fullUrl));
            if (!res.ok) {
                if (localName.match(/\.(png|jpe?g|gif|svg|webp)$/i)) addFetchedFile(localName, '', true);
                return;
            }
            const isImage = /\.(png|jpe?g|gif|svg|webp|avif|bmp|ico)$/i.test(localName);
            if (isImage) {
                const blob = await res.blob();
                const dataUrl = await new Promise(r => {
                    const reader = new FileReader();
                    reader.onload = () => r(reader.result);
                    reader.onerror = () => r('');
                    reader.readAsDataURL(blob);
                });
                addFetchedFile(localName, dataUrl || '', true);
                fetchedFiles.push({ name: localName, blob, dataUrl, type: blob.type });
            } else {
                const text = await res.text();
                if (text.includes('552')) {
                    addFetchedFile(localName, '// Failed due to 552 error', false);
                } else {
                    addFetchedFile(localName, text, false);
                }
                fetchedFiles.push({ name: localName, content: text, type: 'text/plain' });
            }
        } catch (e) {
            if (localName.match(/\.(png|jpe?g|gif|svg|webp)$/i)) addFetchedFile(localName, '', true);
        }
        done++;
        progress.textContent = `Fetching assets (${done}/${assets.length})`;
    }));
    return Array.from(internalLinks);
}
// Fetch button
document.getElementById('fetch-btn').addEventListener('click', async () => {
    let url = document.getElementById('url-input').value.trim();
    if (!url) return alert('Enter a URL');
    if (!url.startsWith('http')) url = 'https://' + url;
    const container = document.getElementById('fetched-files');
    const progress = document.getElementById('progress');
    const zipBtn = document.getElementById('download-zip');
    const singleBtn = document.getElementById('download-single');
    container.innerHTML = '';
    progress.style.display = 'block';
    progress.style.background = '#330';
    progress.textContent = 'Starting crawl...';
    progress.classList.remove('error-status');
    zipBtn.style.display = 'none';
    singleBtn.style.display = 'none';
    fetchedFiles = [];
    globalVisitedUrls = new Set();
    const rootUrl = new URL(url).origin + '/';
    const queue = [url];
    const maxDepth = 5;
    let depth = 0;
    while (queue.length > 0 && depth <= maxDepth) {
        const levelSize = queue.length;
        for (let i = 0; i < levelSize; i++) {
            const current = queue.shift();
            const newLinks = await processPage(current, rootUrl, progress);
            queue.push(...newLinks.filter(l => !globalVisitedUrls.has(l)));
        }
        depth++;
    }
    if (fetchedFiles.length === 0) {
        progress.textContent = 'Failed to fetch any files';
        progress.style.background = '#500';
        progress.classList.add('error-status');
    } else {
        progress.textContent = 'Done! All files fetched.';
        progress.style.background = '#030';
    }
    const show = fetchedFiles.length > 0 ? 'block' : 'none';
    zipBtn.style.display = show;
    singleBtn.style.display = show;
});
function addFetchedFile(name, content, isImage = false) {
    const div = document.createElement('div');
    div.className = 'file-section';
    const safeName = name.replace(/[<'">]/g, '');
    if (isImage) {
        const dataUrl = content || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
        div.innerHTML = `
            <div class="file-header">
                <div class="file-name">${safeName}</div>
                <button class="download-btn" data-content="${dataUrl.replace(/"/g, '&quot;')}" data-name="${safeName}">Download</button>
            </div>
            <img src="${dataUrl}" style="max-width:100%;border-radius:8px;margin-top:10px;display:block;">`;
    } else {
        const taId = 'ta_' + Date.now() + Math.floor(Math.random() * 100000);
        const safeContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        div.innerHTML = `
            <div class="file-header">
                <div class="file-name">${safeName}</div>
                <button class="copy-btn" data-id="${taId}">Copy</button>
                <button class="download-btn" data-id="${taId}" data-name="${safeName}">Download</button>
            </div>
            <textarea id="${taId}" class="file-content" readonly>${safeContent}</textarea>`;
    }
    document.getElementById('fetched-files').appendChild(div);
}
// Fetched files buttons
document.getElementById('fetched-files').addEventListener('click', e => {
    if (e.target.matches('.copy-btn')) {
        const ta = document.getElementById(e.target.dataset.id);
        if (ta) { ta.select(); document.execCommand('copy'); }
    }
    if (e.target.matches('.download-btn')) {
        if (e.target.dataset.content) {
            const a = document.createElement('a');
            a.href = e.target.dataset.content;
            a.download = e.target.dataset.name;
            a.click();
        } else if (e.target.dataset.id) {
            const ta = document.getElementById(e.target.dataset.id);
            if (ta) downloadFile(e.target.dataset.name, ta.value.replace(/&lt;/g, '<').replace(/&gt;/g, '>'));
        }
    }
});
// ZIP Download
document.getElementById('download-zip').addEventListener('click', async () => {
    if (fetchedFiles.length === 0) return;
    const zip = new JSZip();
    fetchedFiles.forEach(f => {
        if (f.blob) zip.file(f.name, f.blob);
        else if (f.content) zip.file(f.name, f.content);
    });
    const btn = document.getElementById('download-zip');
    btn.disabled = true;
    btn.textContent = 'Generating ZIP...';
    const blob = await zip.generateAsync({type: 'blob'});
    downloadFile('website.zip', blob, 'application/zip');
    btn.disabled = false;
    btn.textContent = 'Download All as ZIP';
});

// NEW: Single HTML Download
document.getElementById('download-single').addEventListener('click', () => {
    if (fetchedFiles.length === 0) return;

    // Find main HTML (prefer index.html or first .html)
    let mainHtml = fetchedFiles.find(f => f.name === 'index.html' || f.name.endsWith('/') && f.name.includes('index'));
    if (!mainHtml) mainHtml = fetchedFiles.find(f => f.name.endsWith('.html'));
    if (!mainHtml || !mainHtml.content) {
        alert('No HTML page found to use as base.');
        return;
    }

    let html = mainHtml.content;

    // Create a temporary DOM to work with
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // Inline CSS files
    const cssFiles = fetchedFiles.filter(f => f.name.endsWith('.css') && f.content);
    cssFiles.forEach(cssFile => {
        const style = document.createElement('style');
        style.textContent = cssFile.content;
        doc.head.appendChild(style);
    });

    // Inline JS files
    const jsFiles = fetchedFiles.filter(f => f.name.endsWith('.js') && f.content);
    jsFiles.forEach(jsFile => {
        const script = document.createElement('script');
        script.textContent = jsFile.content;
        doc.body.appendChild(script);
    });

    // Inline images and other assets that have dataUrl
    fetchedFiles.forEach(file => {
        if (file.dataUrl) {
            doc.querySelectorAll(`[src="${file.name}"], [href="${file.name}"]`).forEach(el => {
                const attr = el.hasAttribute('src') ? 'src' : 'href';
                el.setAttribute(attr, file.dataUrl);
            });
        }
    });

    const finalHtml = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
    downloadFile('website-single.html', finalHtml, 'text/html');
});

// Start with example
addFile();
</script>
</body>
</html>
